import { ipcMain } from "electron";
import { DatabaseClient } from "@liga/backend/lib";
import log from "electron-log";
import { levelFromElo } from "@liga/backend/lib/levels";
import { FaceitMatchmaker } from "@liga/backend/lib/matchmaker";
import { Server as Game } from "@liga/backend/lib/game";

// MatchRoom shape generated by FaceitMatchmaker
type MatchPlayer = {
  id: number;
  name: string;
  elo: number;
  level: number;
  role: string | null;
  personality: string | null;
  userControlled: boolean;
  countryId: number;
};

type MatchRoom = {
  matchId: string;
  teamA: MatchPlayer[];
  teamB: MatchPlayer[];
  expectedWinA: number;
  expectedWinB: number;
  eloGain: number;
  eloLoss: number;
};

// ------------------------------------------------------
// Helper: build a Prisma-like "match" object for Game
// ------------------------------------------------------
function buildFaceitPseudoMatch(profile: any, room: MatchRoom) {
  // Base fake team used to satisfy shape; real players are
  // injected in game.ts constructor via faceitRoom.teamA/B
  const baseTeam = {
    id: 0,
    name: "FACEIT TEAM",
    slug: "faceit",
    countryId: profile.player?.countryId ?? 0,
    country: {
      id: profile.player?.countryId ?? 0,
      code: profile.player?.country?.code ?? "EU",
      name: profile.player?.country?.name ?? "Europe",
      continentId: 0,
    },
    players: [] as any[], // game.ts ignores this for FACEIT, rebuilds from faceitRoom
    blazon: "",
    tier: 1,
  };

  const baseCompetitor = {
    id: 0,
    teamId: baseTeam.id,
    position: 1,
    group: null as any,
    team: baseTeam,
  };

  // Important: game.ts only cares about:
  // - match.competition.* for NON-FACEIT (we skip that in isFaceit)
  // - match.competitors when NOT isFaceit (we override competitors in ctor)
  // - match.games to find matchGame (status !== COMPLETED)
  //
  // For isFaceit = true, your game.ts:
  // - uses hostname override
  // - uses random map override
  // - builds competitors from faceitRoom
  // - skips MOTD / standings logic
  //
  // So this pseudo match just needs to satisfy the type,
  // and not crash if accidentally inspected.

  return {
    // Custom FACEIT fields read by game.ts
    isFaceit: true,
    faceitRoom: room,

    // Basic match fields
    id: 0,
    round: 1,
    totalRounds: 1,
    competitionId: 0,

    competition: {
      id: 0,
      name: "FACEIT",
      slug: "faceit",
      federationId: 0,

      federation: {
        id: 0,
        name: "FACEIT",
        slug: "faceit",
      },

      tierId: 0,
      tier: {
        id: 0,
        name: "FACEIT",
        slug: "faceit",
        groupSize: null,
        startOffsetDays: 0,
        leagueId: 0,
        league: {
          id: 0,
          name: "FACEIT",
          slug: "faceit",
          startOffsetDays: 0,
        },
      },

      // Tournament competitors (not really used in FACEIT path)
      competitors: [baseCompetitor, { ...baseCompetitor, id: 1 }],
    },

    // Match competitors that game.ts *would* use normally.
    // In FACEIT mode, your constructor overrides competitors
    // completely from faceitRoom, so these are just dummy.
    competitors: [
      {
        ...baseCompetitor,
        id: 0,
        teamId: 1,
        team: {
          ...baseTeam,
          id: 1,
          slug: "faceit-a",
          name: "FACEIT TEAM A",
        },
      },
      {
        ...baseCompetitor,
        id: 1,
        teamId: 2,
        team: {
          ...baseTeam,
          id: 2,
          slug: "faceit-b",
          name: "FACEIT TEAM B",
        },
      },
    ],

    games: [
      {
        id: 0,
        map: null,          // game.ts will pick a random FACEIT map
        status: "PENDING",  // so matchGame is this one
        matchId: 0,
        teams: [],          // not needed for FACEIT
      },
    ],

    _count: {
      events: 0,
    },
  } as any;
}

export default function registerFaceitHandlers() {
  // ------------------------------------------------------
  // GET FACEIT PROFILE (user)
  // ------------------------------------------------------
  ipcMain.handle("faceit:getProfile", async () => {
    try {
      const prisma = await DatabaseClient.connect();

      const profile = await prisma.profile.findFirst({
        include: { player: true },
      });

      if (!profile) {
        throw new Error("No active profile found");
      }

      return {
        faceitElo: profile.faceitElo,
        faceitLevel: levelFromElo(profile.faceitElo),
        recent: [], // TODO: plug real match history later
      };
    } catch (err) {
      log.error(err);
      throw err;
    }
  });

  // ------------------------------------------------------
  // QUEUE PUG → create matchroom
  // ------------------------------------------------------
  ipcMain.handle("faceit:queuePug", async () => {
    try {
      await DatabaseClient.connect(); // sets correct save DB
      const prisma = DatabaseClient.prisma;

      const profile = await prisma.profile.findFirst({
        include: {
          player: {
            include: {
              country: {
                include: {
                  continent: {
                    include: {
                      federation: true,
                    },
                  },
                },
              },
            },
          },
        },
      });

      if (!profile) throw new Error("No active profile found");
      if (!profile.player) throw new Error("Active profile has no linked player");

      const user = {
        id: profile.player.id,
        name: profile.player.name,
        elo: profile.faceitElo,
      };

      log.info(`Queueing FACEIT PUG for ${user.name} (Elo ${user.elo})…`);

      const matchRoom = await FaceitMatchmaker.createMatchRoom(prisma, user);

      log.info(`Created FACEIT matchroom ${matchRoom.matchId}`);

      // matchRoom matches the MatchRoom type above
      return matchRoom;
    } catch (err) {
      log.error(err);
      throw err;
    }
  });

  // ------------------------------------------------------
  // START FACEIT MATCH
  // ------------------------------------------------------
  ipcMain.handle("faceit:startMatch", async (_, matchRoom: MatchRoom) => {
    try {
      await DatabaseClient.connect();
      const prisma = DatabaseClient.prisma;

      // Load full profile with settings + player country for flags
      const profile = await prisma.profile.findFirst({
        include: {
          player: {
            include: {
              country: true,
            },
          },
        },
      });

      if (!profile) throw new Error("No active profile found");

      // Build a pseudo-match compatible with Game(Server) expectations.
      const match = buildFaceitPseudoMatch(profile, matchRoom);

      // Create Game instance in FACEIT mode (isFaceit + faceitRoom)
      const game = new Game(profile, match, null, false);

      // Start the actual match (prepare → server → client)
      await game.start();

      return { ok: true };
    } catch (err) {
      log.error(err);
      throw err;
    }
  });
}
